#----------------------------------------------------------------------#
# main.py
#  
# This application simulates a single server with Poisson arrivals 
# and processing times of a general distribution. There are errors in
# time estimates within a range. Arrivals are assigned to SRPT classes
# using the methods described in Adaptive and Scalable Comparison Scheduling.
# 
# Rachel Mailach
#----------------------------------------------------------------------#

from SimPy.Simulation import *
from Tkinter import *
from random import Random,expovariate,uniform,normalvariate # https://docs.python.org/2/library/random.html
import ttk

#----------------------------------------------------------------------#
# Class: GUI
#  
# This class is used as a graphical user interface for a larger
# application.
# 
#----------------------------------------------------------------------#
class GUI(object):
	def __init__(self, win, title = '

#----------------------------------------------------------------------#
# Class: Input
#  
# This class is used as a graphical user interface for a larger
# application.
# 
#----------------------------------------------------------------------#
lass Input(LabelFrame):
	def __init__(self, parent):
		LabelFrame.__init__(self, parent, text = "Input")
		self.makeConsole()

		self.arrivalRateInput = DoubleVar()
		self.processingRateInput = DoubleVar()
		self.percentErrorInput = DoubleVar()
		self.simLengthInput = DoubleVar()

		# create widgets, parent = self because window is parent
		# Labels	
		labels = [u'\u03bb', u'\u03bc', '% error     ' u"\u00B1", 'simulation length']
		r=0
		c=0
		for elem in labels:
			Label(self, text=elem).grid(row=r, column=c)
			r=r+1
			if r > 3:
				r=0
				c=3
			
		# Entry Boxes
		self.entry_1 = Entry(self, textvariable = self.arrivalRateInput)
		self.entry_2 = Entry(self, textvariable = self.processingRateInput)
		self.entry_3 = Entry(self, textvariable = self.percentErrorInput)
		self.entry_4 = Entry(self, textvariable = self.simLengthInput)

		# Simulate Button
		self.simulateButton = Button(self, text = "SIMULATE", command = self.OnButtonClick)

		self.distributions = ('Select Distribution', 'Exponential', 'Normal', 'Custom')

		#self.comboBox_1 = ttk.Combobox(self, values = self.distributions, state = 'readonly')
		#self.comboBox_1.current(0) # set selection

		self.comboBox_2 = ttk.Combobox(self, values = self.distributions, state = 'readonly')
		self.comboBox_2.current(0) # set selection


		self.entry_1.grid(row = 0, column = 1)
		self.entry_2.grid(row = 1, column = 1)
		self.entry_3.grid(row = 2, column = 1)
		self.entry_4.grid(row = 3, column = 1)
		
		self.simulateButton.grid(row = 4, columnspan = 2)
	
		#self.comboBox_1.grid(row = 0, column = 2)
		self.comboBox_2.grid(row = 1, column = 2)

				
	def makeConsole(self):
		#grab all output values
		scrollbar = Scrollbar(self)
		scrollbar.pack(side = RIGHT, fill = Y)
		output = Frame(self)

		self.console = Text(output, wrap = WORD, yscrollcommand = scrollbar.set, state=DISABLED)
		self.console.pack()
		scrollbar.config(command = self.console.yview)
		output.pack()

	def writeToConsole(self, text = ' '):
		self.console.insert(END, '%s\n'%text)
		self.update()
	


	def OnButtonClick(self):
		self.GetNumericValues()
		self.GetDropDownValues()

		# send to submit button in main
		self.simulateButton.event_generate("<<input_simulate>>")	
			

	def GetNumericValues(self):
		arrivalRate = self.arrivalRateInput.get()
		processingRate = self.processingRateInput.get()
		percentError = self.percentErrorInput.get()
		maxSimLength = self.simLengthInput.get()
	

		if arrivalRate >= 0: writeToConsole("Arrival rate has to be non-zero!")
		if processingRate >= 0.0: print "Processing rate has to be non-zero!"
		if percentError >= 0.0: print "Percent error has to be non-zero!"
		if maxSimLength >= 0.0: print "Simulation length has to be non-zero!"

		Input.valuesList = [arrivalRate, processingRate, percentError, maxSimLength]
		return Input.valuesList
		
	def GetDropDownValues(self):
		#if self.comboBox_1.get() == 'Select Distribution': print "Box 1 has to have a selection"
		if self.comboBox_2.get() == 'Select Distribution': print "Box 2 has to have a selection"

		Input.distList = ["", self.comboBox_2.get(), "", ""]
		return Input.distList

	def CreateList(self):
		InputList = zip(Input.valuesList, Input.distList)
		return InputList


#----------------------------------------------------------------------#
# Class: Output
#  
# This class is used as a graphical user interface for a larger
# application.
#
#----------------------------------------------------------------------#
class Output(LabelFrame):
	def __init__(self, parent):
		LabelFrame.__init__(self, parent, text = "Output")	
	


#----------------------------------------------------------------------#
# Class: MyWindow
#  
# This class is used to manage the application.
# 
#----------------------------------------------------------------------#
class MyWindow(Tk):
	def __init__(self, parent):
		Tk.__init__(self, parent)	# Because GUIs are hierarchical, it is a good idea to keep track of parent widgets
		self.parent = parent		# reference to parent
		self.initialize()

	def initialize(self):		
		#self.process = simulation.Model()		

		# create the input frame
		self.frameIn = Input(self)
		self.frameIn.grid(row = 0, column = 0, padx = 5, pady =5, ipadx = 5, ipady = 5)

		# create the output frame
		self.frameOut = Output(self)
		self.frameOut.grid(row = 1, column = 0, padx = 5, pady =5, ipadx = 5, ipady = 5)

		# bind simulate button
		self.bind("<<input_simulate>>", self.submit)
	
	def submit(self, event):
		simulation.Run(self)
		self.frameOut.GetOutputList()

def main():
	window = MyWindow(None)							# instantiate the class with no parent (None)
	window.title('Single Server SRPT with Errors')	# title the window	
	#window.geometry("500x600")						# set window size
	window.mainloop()								# loop indefinitely, wait for events


if __name__ == '__main__': main()


